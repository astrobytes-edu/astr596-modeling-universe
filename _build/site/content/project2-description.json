{"version":2,"kind":"Article","sha256":"4fd2daae84007f0520b26be51dcb897acbd791960b7da96d2dced904d0c61623","slug":"project2-description","location":"/short-projects/2_project2_description.md","dependencies":[],"frontmatter":{"title":"ASTR 596 Project 2: N-Body Dynamics + Statistical Sampling + Stellar Systems","content_includes_title":false,"github":"https://github.com/astrobytes-edu/astr596-modeling-universe","numbering":{"title":{"offset":1}},"edit_url":"https://github.com/astrobytes-edu/astr596-modeling-universe/blob/main/short-projects/2_project2_description.md","exports":[{"format":"md","filename":"2_project2_description.md","url":"/2_project2_descripti-64a81361f2bfa29ba49ee57930002edf.md"}]},"mdast":{"type":"root","children":[{"type":"block","children":[{"type":"paragraph","position":{"start":{"line":2,"column":1},"end":{"line":4,"column":1}},"children":[{"type":"strong","position":{"start":{"line":2,"column":1},"end":{"line":2,"column":1}},"children":[{"type":"text","value":"Duration","position":{"start":{"line":2,"column":1},"end":{"line":2,"column":1}},"key":"Xpv4rqBLlN"}],"key":"i3tYK6Nc89"},{"type":"text","value":": 3 weeks\n","position":{"start":{"line":2,"column":1},"end":{"line":2,"column":1}},"key":"sBe8Qk3LOK"},{"type":"strong","position":{"start":{"line":2,"column":1},"end":{"line":2,"column":1}},"children":[{"type":"text","value":"Weight","position":{"start":{"line":2,"column":1},"end":{"line":2,"column":1}},"key":"aEvgoSb7N2"}],"key":"E13AUGkuHM"},{"type":"text","value":": 15% of course grade\n","position":{"start":{"line":2,"column":1},"end":{"line":2,"column":1}},"key":"KOhVfJoZXC"},{"type":"strong","position":{"start":{"line":2,"column":1},"end":{"line":2,"column":1}},"children":[{"type":"text","value":"Theme","position":{"start":{"line":2,"column":1},"end":{"line":2,"column":1}},"key":"hg6BwSNPYA"}],"key":"aXdd7F2c5J"},{"type":"text","value":": “Realistic Stellar Clusters with Gravitational Dynamics”","position":{"start":{"line":2,"column":1},"end":{"line":2,"column":1}},"key":"zk1C35gzWj"}],"key":"EoL7cn1GFg"},{"type":"thematicBreak","position":{"start":{"line":6,"column":1},"end":{"line":6,"column":1}},"key":"zmUCGaxcGJ"},{"type":"heading","depth":3,"position":{"start":{"line":8,"column":1},"end":{"line":8,"column":1}},"children":[{"type":"text","value":"Project Overview","position":{"start":{"line":8,"column":1},"end":{"line":8,"column":1}},"key":"JZCCpO7nXD"}],"identifier":"project-overview","label":"Project Overview","html_id":"project-overview","implicit":true,"key":"lro4y8CEAC"},{"type":"paragraph","position":{"start":{"line":10,"column":1},"end":{"line":10,"column":1}},"children":[{"type":"text","value":"This project builds sophisticated N-body gravitational dynamics simulations with realistic stellar populations. You will implement multiple ODE integration schemes, master statistical sampling from astrophysical distributions, and create evolving stellar clusters that serve as input for radiation calculations in Project 3. The emphasis is on vectorization, performance optimization, and adaptive numerical methods.","position":{"start":{"line":10,"column":1},"end":{"line":10,"column":1}},"key":"yFiToNiW2Y"}],"key":"Wes9T7GgrF"},{"type":"heading","depth":3,"position":{"start":{"line":12,"column":1},"end":{"line":12,"column":1}},"children":[{"type":"text","value":"Learning Objectives","position":{"start":{"line":12,"column":1},"end":{"line":12,"column":1}},"key":"hIbtl8EvwI"}],"identifier":"learning-objectives","label":"Learning Objectives","html_id":"learning-objectives","implicit":true,"key":"cK0UxPbH1a"},{"type":"paragraph","position":{"start":{"line":14,"column":1},"end":{"line":14,"column":1}},"children":[{"type":"text","value":"By completing this project, you will:","position":{"start":{"line":14,"column":1},"end":{"line":14,"column":1}},"key":"rY7AVjhR5f"}],"key":"ujsJEA6Hur"},{"type":"list","ordered":false,"spread":false,"position":{"start":{"line":15,"column":1},"end":{"line":21,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":15,"column":1},"end":{"line":15,"column":1}},"children":[{"type":"strong","position":{"start":{"line":15,"column":1},"end":{"line":15,"column":1}},"children":[{"type":"text","value":"Master ODE integration","position":{"start":{"line":15,"column":1},"end":{"line":15,"column":1}},"key":"c9uOieNlqv"}],"key":"ll2rOxH1HL"},{"type":"text","value":": Implement and compare multiple numerical integration schemes","position":{"start":{"line":15,"column":1},"end":{"line":15,"column":1}},"key":"cqqPUNzGop"}],"key":"aNm7aHkkRu"},{"type":"listItem","spread":true,"position":{"start":{"line":16,"column":1},"end":{"line":16,"column":1}},"children":[{"type":"strong","position":{"start":{"line":16,"column":1},"end":{"line":16,"column":1}},"children":[{"type":"text","value":"Understand gravitational dynamics","position":{"start":{"line":16,"column":1},"end":{"line":16,"column":1}},"key":"JLa8n09fML"}],"key":"vSd4GDSxZ3"},{"type":"text","value":": N-body physics, energy conservation, and cluster evolution","position":{"start":{"line":16,"column":1},"end":{"line":16,"column":1}},"key":"rUWdWdrmaA"}],"key":"oimXyhhiuv"},{"type":"listItem","spread":true,"position":{"start":{"line":17,"column":1},"end":{"line":17,"column":1}},"children":[{"type":"strong","position":{"start":{"line":17,"column":1},"end":{"line":17,"column":1}},"children":[{"type":"text","value":"Learn statistical sampling","position":{"start":{"line":17,"column":1},"end":{"line":17,"column":1}},"key":"Ac0EdbTbl3"}],"key":"BUidmiBB14"},{"type":"text","value":": Sample from Initial Mass Function and spatial distributions","position":{"start":{"line":17,"column":1},"end":{"line":17,"column":1}},"key":"L9GikLQjWI"}],"key":"wBGGtKNzF7"},{"type":"listItem","spread":true,"position":{"start":{"line":18,"column":1},"end":{"line":18,"column":1}},"children":[{"type":"strong","position":{"start":{"line":18,"column":1},"end":{"line":18,"column":1}},"children":[{"type":"text","value":"Develop vectorization skills","position":{"start":{"line":18,"column":1},"end":{"line":18,"column":1}},"key":"tS9SKpofDb"}],"key":"CZhwkC82Bn"},{"type":"text","value":": Efficient NumPy operations for computational performance","position":{"start":{"line":18,"column":1},"end":{"line":18,"column":1}},"key":"t42lAsJLtp"}],"key":"zuvNevbVD0"},{"type":"listItem","spread":true,"position":{"start":{"line":19,"column":1},"end":{"line":19,"column":1}},"children":[{"type":"strong","position":{"start":{"line":19,"column":1},"end":{"line":19,"column":1}},"children":[{"type":"text","value":"Implement adaptive methods","position":{"start":{"line":19,"column":1},"end":{"line":19,"column":1}},"key":"iew0LF3SbL"}],"key":"g6s0ZmKcWN"},{"type":"text","value":": Energy-controlled timestep adjustment","position":{"start":{"line":19,"column":1},"end":{"line":19,"column":1}},"key":"cmuYEwnTGC"}],"key":"kfICiIV31u"},{"type":"listItem","spread":true,"position":{"start":{"line":20,"column":1},"end":{"line":21,"column":1}},"children":[{"type":"strong","position":{"start":{"line":20,"column":1},"end":{"line":20,"column":1}},"children":[{"type":"text","value":"Generate realistic astrophysical data","position":{"start":{"line":20,"column":1},"end":{"line":20,"column":1}},"key":"I8hTeckXHZ"}],"key":"OHajbqJBaI"},{"type":"text","value":": Stellar clusters for radiation modeling","position":{"start":{"line":20,"column":1},"end":{"line":20,"column":1}},"key":"DKnWTBgiPx"}],"key":"FP234n8iBK"}],"key":"xYK55vPjmI"},{"type":"heading","depth":3,"position":{"start":{"line":22,"column":1},"end":{"line":22,"column":1}},"children":[{"type":"text","value":"Prerequisites from Project 1","position":{"start":{"line":22,"column":1},"end":{"line":22,"column":1}},"key":"smIyhnjfjL"}],"identifier":"prerequisites-from-project-1","label":"Prerequisites from Project 1","html_id":"prerequisites-from-project-1","implicit":true,"key":"WiJOyGs7xG"},{"type":"list","ordered":false,"spread":false,"position":{"start":{"line":23,"column":1},"end":{"line":27,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":23,"column":1},"end":{"line":23,"column":1}},"children":[{"type":"text","value":"Numerical integration techniques (trapezoid, Simpson’s, Gaussian quadrature)","position":{"start":{"line":23,"column":1},"end":{"line":23,"column":1}},"key":"RSfTXGM7hD"}],"key":"xZKA6oXc1V"},{"type":"listItem","spread":true,"position":{"start":{"line":24,"column":1},"end":{"line":24,"column":1}},"children":[{"type":"text","value":"Root-finding methods (Newton-Raphson for energy balance)","position":{"start":{"line":24,"column":1},"end":{"line":24,"column":1}},"key":"sPnBU7JxDl"}],"key":"wvA3MdLj7z"},{"type":"listItem","spread":true,"position":{"start":{"line":25,"column":1},"end":{"line":25,"column":1}},"children":[{"type":"text","value":"Object-oriented programming (Star class design)","position":{"start":{"line":25,"column":1},"end":{"line":25,"column":1}},"key":"z2QBU1PaNO"}],"key":"Lkw0Yte11Z"},{"type":"listItem","spread":true,"position":{"start":{"line":26,"column":1},"end":{"line":27,"column":1}},"children":[{"type":"text","value":"Blackbody physics and stellar luminosity calculations","position":{"start":{"line":26,"column":1},"end":{"line":26,"column":1}},"key":"aCgk22cyCn"}],"key":"MuFq3smzFu"}],"key":"iK8VMW2ZQ5"},{"type":"thematicBreak","position":{"start":{"line":28,"column":1},"end":{"line":28,"column":1}},"key":"zEDIB55YXB"},{"type":"heading","depth":2,"position":{"start":{"line":30,"column":1},"end":{"line":30,"column":1}},"children":[{"type":"text","value":"Week 1: ODE Solvers and Energy Conservation","position":{"start":{"line":30,"column":1},"end":{"line":30,"column":1}},"key":"mxEy0bRUwa"}],"identifier":"week-1-ode-solvers-and-energy-conservation","label":"Week 1: ODE Solvers and Energy Conservation","html_id":"week-1-ode-solvers-and-energy-conservation","implicit":true,"key":"qYbxoiGoLX"},{"type":"heading","depth":3,"position":{"start":{"line":32,"column":1},"end":{"line":32,"column":1}},"children":[{"type":"text","value":"Conceptual Introduction (25 min)","position":{"start":{"line":32,"column":1},"end":{"line":32,"column":1}},"key":"Q3gFVJSOU2"}],"identifier":"conceptual-introduction-25-min","label":"Conceptual Introduction (25 min)","html_id":"conceptual-introduction-25-min","implicit":true,"key":"MflnqpPXek"},{"type":"list","ordered":false,"spread":false,"position":{"start":{"line":33,"column":1},"end":{"line":38,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":33,"column":1},"end":{"line":33,"column":1}},"children":[{"type":"text","value":"Newton’s laws and gravitational force in astrophysical contexts","position":{"start":{"line":33,"column":1},"end":{"line":33,"column":1}},"key":"kFlpWImD4t"}],"key":"QgQqdP9PJi"},{"type":"listItem","spread":true,"position":{"start":{"line":34,"column":1},"end":{"line":34,"column":1}},"children":[{"type":"text","value":"Converting 2nd order ODEs to 1st order systems","position":{"start":{"line":34,"column":1},"end":{"line":34,"column":1}},"key":"VBfzOLjDcR"}],"key":"pW84E9EC6K"},{"type":"listItem","spread":true,"position":{"start":{"line":35,"column":1},"end":{"line":35,"column":1}},"children":[{"type":"text","value":"Integration methods: explicit vs implicit, stability vs accuracy","position":{"start":{"line":35,"column":1},"end":{"line":35,"column":1}},"key":"VTQJMlY4zw"}],"key":"eb2H0hozQ7"},{"type":"listItem","spread":true,"position":{"start":{"line":36,"column":1},"end":{"line":36,"column":1}},"children":[{"type":"text","value":"Symplectic integrators for Hamiltonian systems","position":{"start":{"line":36,"column":1},"end":{"line":36,"column":1}},"key":"aqBi3jI8UO"}],"key":"soVDPRHMXX"},{"type":"listItem","spread":true,"position":{"start":{"line":37,"column":1},"end":{"line":38,"column":1}},"children":[{"type":"text","value":"Energy and angular momentum conservation in gravitational systems","position":{"start":{"line":37,"column":1},"end":{"line":37,"column":1}},"key":"LELgUELSXF"}],"key":"Kj8OPhHFQe"}],"key":"dct1GH69S3"},{"type":"heading","depth":3,"position":{"start":{"line":39,"column":1},"end":{"line":39,"column":1}},"children":[{"type":"text","value":"Lab Session Objectives","position":{"start":{"line":39,"column":1},"end":{"line":39,"column":1}},"key":"hd3AXco2Mc"}],"identifier":"lab-session-objectives","label":"Lab Session Objectives","html_id":"lab-session-objectives","implicit":true,"key":"zaRIqiKcyA"},{"type":"paragraph","position":{"start":{"line":40,"column":1},"end":{"line":40,"column":1}},"children":[{"type":"text","value":"Build comprehensive ODE solver library and validate on two-body dynamics.","position":{"start":{"line":40,"column":1},"end":{"line":40,"column":1}},"key":"R9dU5OHOPI"}],"key":"nHw03qr1w7"},{"type":"heading","depth":4,"position":{"start":{"line":42,"column":1},"end":{"line":42,"column":1}},"children":[{"type":"text","value":"Task 1: ODE Solver Framework (45 min)","position":{"start":{"line":42,"column":1},"end":{"line":42,"column":1}},"key":"xlpqqZ27hy"}],"identifier":"task-1-ode-solver-framework-45-min","label":"Task 1: ODE Solver Framework (45 min)","html_id":"task-1-ode-solver-framework-45-min","implicit":true,"key":"RyZaLrdIFC"},{"type":"paragraph","position":{"start":{"line":43,"column":1},"end":{"line":43,"column":1}},"children":[{"type":"strong","position":{"start":{"line":43,"column":1},"end":{"line":43,"column":1}},"children":[{"type":"text","value":"Goal","position":{"start":{"line":43,"column":1},"end":{"line":43,"column":1}},"key":"N3SZWZlBAt"}],"key":"ZSfNHFLTXN"},{"type":"text","value":": Create abstract base class and implement multiple integration methods","position":{"start":{"line":43,"column":1},"end":{"line":43,"column":1}},"key":"tYXOLfIxN2"}],"key":"hnDaT8DF1t"},{"type":"paragraph","position":{"start":{"line":45,"column":1},"end":{"line":45,"column":1}},"children":[{"type":"strong","position":{"start":{"line":45,"column":1},"end":{"line":45,"column":1}},"children":[{"type":"text","value":"Framework Design","position":{"start":{"line":45,"column":1},"end":{"line":45,"column":1}},"key":"Jl6biLllbT"}],"key":"xXq9iRuwmN"},{"type":"text","value":":","position":{"start":{"line":45,"column":1},"end":{"line":45,"column":1}},"key":"mmUbl5oJCl"}],"key":"z8D4akw6EK"},{"type":"code","lang":"python","value":"from abc import ABC, abstractmethod\nimport numpy as np\n\nclass ODESolver(ABC):\n    \"\"\"\n    Abstract base class for ODE integration methods.\n    \n    Solves system: dy/dt = f(t, y) where y can be vector-valued\n    \"\"\"\n    \n    def __init__(self, derivatives_func, initial_conditions, initial_time=0.0):\n        \"\"\"\n        Parameters:\n        -----------\n        derivatives_func : callable\n            Function f(t, y) returning dy/dt\n        initial_conditions : array_like\n            Initial values y(t0)\n        initial_time : float\n            Initial time t0\n        \"\"\"\n        self.f = derivatives_func\n        self.y = np.array(initial_conditions, dtype=float)\n        self.t = initial_time\n        self.history = {'t': [initial_time], 'y': [self.y.copy()]}\n    \n    @abstractmethod\n    def step(self, dt):\n        \"\"\"Take single integration step of size dt.\"\"\"\n        pass\n    \n    def evolve(self, t_final, dt):\n        \"\"\"Evolve system from current time to t_final.\"\"\"\n        while self.t < t_final:\n            step_size = min(dt, t_final - self.t)\n            self.step(step_size)\n            self.history['t'].append(self.t)\n            self.history['y'].append(self.y.copy())\n        return np.array(self.history['t']), np.array(self.history['y'])\n\nclass EulerSolver(ODESolver):\n    \"\"\"First-order Euler method: y_{n+1} = y_n + dt * f(t_n, y_n)\"\"\"\n    \n    def step(self, dt):\n        \"\"\"Implement Euler step.\"\"\"\n        dydt = self.f(self.t, self.y)\n        self.y += dt * dydt\n        self.t += dt\n\nclass RungeKutta4Solver(ODESolver):\n    \"\"\"Fourth-order Runge-Kutta method.\"\"\"\n    \n    def step(self, dt):\n        \"\"\"Implement RK4 step with four evaluations.\"\"\"\n        k1 = self.f(self.t, self.y)\n        k2 = self.f(self.t + dt/2, self.y + dt*k1/2)\n        k3 = self.f(self.t + dt/2, self.y + dt*k2/2)\n        k4 = self.f(self.t + dt, self.y + dt*k3)\n        \n        self.y += dt * (k1 + 2*k2 + 2*k3 + k4) / 6\n        self.t += dt\n\nclass LeapfrogSolver(ODESolver):\n    \"\"\"\n    Leapfrog integrator for Hamiltonian systems.\n    Particularly good for gravitational dynamics.\n    \"\"\"\n    \n    def __init__(self, force_func, positions, velocities, masses, initial_time=0.0):\n        \"\"\"\n        Specialized for N-body problems.\n        \n        Parameters:\n        -----------\n        force_func : callable\n            Function returning accelerations given (positions, masses)\n        positions : array\n            Initial positions [N, 3]\n        velocities : array  \n            Initial velocities [N, 3]\n        masses : array\n            Particle masses [N]\n        \"\"\"\n        self.force_func = force_func\n        self.positions = np.array(positions)\n        self.velocities = np.array(velocities)\n        self.masses = np.array(masses)\n        self.t = initial_time\n        self.history = {\n            't': [initial_time],\n            'positions': [self.positions.copy()],\n            'velocities': [self.velocities.copy()]\n        }\n    \n    def step(self, dt):\n        \"\"\"Leapfrog integration step.\"\"\"\n        # Kick: v_{1/2} = v_0 + (dt/2) * a_0\n        accelerations = self.force_func(self.positions, self.masses)\n        self.velocities += 0.5 * dt * accelerations\n        \n        # Drift: x_1 = x_0 + dt * v_{1/2}\n        self.positions += dt * self.velocities\n        \n        # Kick: v_1 = v_{1/2} + (dt/2) * a_1\n        accelerations = self.force_func(self.positions, self.masses)\n        self.velocities += 0.5 * dt * accelerations\n        \n        self.t += dt\n        self.history['t'].append(self.t)\n        self.history['positions'].append(self.positions.copy())\n        self.history['velocities'].append(self.velocities.copy())","position":{"start":{"line":46,"column":1},"end":{"line":158,"column":1}},"key":"rZwtBJQ19b"},{"type":"heading","depth":4,"position":{"start":{"line":160,"column":1},"end":{"line":160,"column":1}},"children":[{"type":"text","value":"Task 2: Two-Body Gravitational Dynamics (60 min)","position":{"start":{"line":160,"column":1},"end":{"line":160,"column":1}},"key":"Xol199zbk2"}],"identifier":"task-2-two-body-gravitational-dynamics-60-min","label":"Task 2: Two-Body Gravitational Dynamics (60 min)","html_id":"task-2-two-body-gravitational-dynamics-60-min","implicit":true,"key":"xjtj4kZ15M"},{"type":"paragraph","position":{"start":{"line":161,"column":1},"end":{"line":161,"column":1}},"children":[{"type":"strong","position":{"start":{"line":161,"column":1},"end":{"line":161,"column":1}},"children":[{"type":"text","value":"Goal","position":{"start":{"line":161,"column":1},"end":{"line":161,"column":1}},"key":"QY4SYjzoPk"}],"key":"BOm0wtXUfh"},{"type":"text","value":": Validate integrators on Kepler problem with known analytical solution","position":{"start":{"line":161,"column":1},"end":{"line":161,"column":1}},"key":"Z0sP5KVxOk"}],"key":"fyW8bsatJF"},{"type":"paragraph","position":{"start":{"line":163,"column":1},"end":{"line":163,"column":1}},"children":[{"type":"strong","position":{"start":{"line":163,"column":1},"end":{"line":163,"column":1}},"children":[{"type":"text","value":"Implementation Requirements","position":{"start":{"line":163,"column":1},"end":{"line":163,"column":1}},"key":"EtvYfGBC5l"}],"key":"inuTTVOMaw"},{"type":"text","value":":","position":{"start":{"line":163,"column":1},"end":{"line":163,"column":1}},"key":"OUNHG0OZsh"}],"key":"BXGDYzhGBa"},{"type":"code","lang":"python","value":"def gravitational_derivatives(t, state):\n    \"\"\"\n    Derivatives for two-body problem.\n    \n    state = [x1, y1, z1, vx1, vy1, vz1, x2, y2, z2, vx2, vy2, vz2]\n    \"\"\"\n    # Extract positions and velocities\n    pos1 = state[0:3]\n    vel1 = state[3:6]\n    pos2 = state[6:9]\n    vel2 = state[9:12]\n    \n    # Calculate separation and force\n    r_vec = pos2 - pos1\n    r_mag = np.linalg.norm(r_vec)\n    \n    # Gravitational acceleration\n    G = 6.674e-11  # m³/kg/s²\n    m1, m2 = 1.0, 1.0  # masses\n    \n    acc_magnitude = G * (m1 + m2) / r_mag**3\n    acc1 = acc_magnitude * r_vec\n    acc2 = -acc_magnitude * r_vec\n    \n    # Return derivatives: [vel1, acc1, vel2, acc2]\n    return np.concatenate([vel1, acc1, vel2, acc2])\n\ndef kepler_orbit_validation():\n    \"\"\"\n    Test integrators on Earth-Sun system.\n    Compare with analytical solution for energy and angular momentum.\n    \"\"\"\n    # Earth-Sun system (simplified units)\n    AU = 1.496e11  # m\n    year = 365.25 * 24 * 3600  # s\n    \n    # Initial conditions: Earth at aphelion\n    initial_state = [\n        1.017*AU, 0, 0,      # Earth position\n        0, 29.29e3, 0,       # Earth velocity\n        0, 0, 0,             # Sun position (at origin)\n        0, 0, 0              # Sun velocity\n    ]\n    \n    # Test each integrator\n    methods = {\n        'Euler': EulerSolver,\n        'RK4': RungeKutta4Solver\n    }\n    \n    results = {}\n    for name, SolverClass in methods.items():\n        solver = SolverClass(gravitational_derivatives, initial_state)\n        t_vals, y_vals = solver.evolve(t_final=year, dt=year/1000)\n        results[name] = {'t': t_vals, 'y': y_vals}\n    \n    return results\n\ndef calculate_orbital_energy(positions, velocities, masses):\n    \"\"\"Calculate total energy: kinetic + potential.\"\"\"\n    # Kinetic energy: (1/2) * m * v²\n    ke = 0.5 * np.sum(masses * np.sum(velocities**2, axis=1))\n    \n    # Potential energy: -G * m1 * m2 / r\n    G = 6.674e-11\n    pe = 0\n    for i in range(len(masses)):\n        for j in range(i+1, len(masses)):\n            r_ij = np.linalg.norm(positions[i] - positions[j])\n            pe -= G * masses[i] * masses[j] / r_ij\n    \n    return ke + pe\n\ndef orbital_validation_analysis(results):\n    \"\"\"\n    Analyze energy conservation and orbital accuracy.\n    Plot energy drift and orbital trajectories.\n    \"\"\"\n    # Calculate energy conservation for each method\n    # Plot trajectories and energy vs time\n    # Compare with analytical orbital period","position":{"start":{"line":164,"column":1},"end":{"line":246,"column":1}},"key":"hBfNsygvVK"},{"type":"heading","depth":4,"position":{"start":{"line":248,"column":1},"end":{"line":248,"column":1}},"children":[{"type":"text","value":"Task 3: Error Analysis and Method Comparison (30 min)","position":{"start":{"line":248,"column":1},"end":{"line":248,"column":1}},"key":"znrJN9Nowc"}],"identifier":"task-3-error-analysis-and-method-comparison-30-min","label":"Task 3: Error Analysis and Method Comparison (30 min)","html_id":"task-3-error-analysis-and-method-comparison-30-min","implicit":true,"key":"Sgi3bYxwiW"},{"type":"paragraph","position":{"start":{"line":249,"column":1},"end":{"line":249,"column":1}},"children":[{"type":"strong","position":{"start":{"line":249,"column":1},"end":{"line":249,"column":1}},"children":[{"type":"text","value":"Goal","position":{"start":{"line":249,"column":1},"end":{"line":249,"column":1}},"key":"FBLYvJA0QN"}],"key":"BAjLRJxggy"},{"type":"text","value":": Understand trade-offs between accuracy, stability, and computational cost","position":{"start":{"line":249,"column":1},"end":{"line":249,"column":1}},"key":"SYfXv6hTkb"}],"key":"zwsZzd9u47"},{"type":"paragraph","position":{"start":{"line":251,"column":1},"end":{"line":251,"column":1}},"children":[{"type":"strong","position":{"start":{"line":251,"column":1},"end":{"line":251,"column":1}},"children":[{"type":"text","value":"Analysis Requirements","position":{"start":{"line":251,"column":1},"end":{"line":251,"column":1}},"key":"TGLm1gkzmW"}],"key":"Vv2ljdBge7"},{"type":"text","value":":","position":{"start":{"line":251,"column":1},"end":{"line":251,"column":1}},"key":"lixWdItpn3"}],"key":"aveUYuutHV"},{"type":"list","ordered":true,"start":1,"spread":false,"position":{"start":{"line":252,"column":1},"end":{"line":256,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":252,"column":1},"end":{"line":252,"column":1}},"children":[{"type":"strong","position":{"start":{"line":252,"column":1},"end":{"line":252,"column":1}},"children":[{"type":"text","value":"Convergence Study","position":{"start":{"line":252,"column":1},"end":{"line":252,"column":1}},"key":"RaEMjgeyzN"}],"key":"SncUTXybR8"},{"type":"text","value":": Plot error vs timestep for each method","position":{"start":{"line":252,"column":1},"end":{"line":252,"column":1}},"key":"SnzOODUSUQ"}],"key":"O2lbxMina6"},{"type":"listItem","spread":true,"position":{"start":{"line":253,"column":1},"end":{"line":253,"column":1}},"children":[{"type":"strong","position":{"start":{"line":253,"column":1},"end":{"line":253,"column":1}},"children":[{"type":"text","value":"Energy Conservation","position":{"start":{"line":253,"column":1},"end":{"line":253,"column":1}},"key":"hbnJMQtjCY"}],"key":"buHa52JIj9"},{"type":"text","value":": Track relative energy drift over multiple orbits","position":{"start":{"line":253,"column":1},"end":{"line":253,"column":1}},"key":"EQrwzAFL9H"}],"key":"D2njfqCCgG"},{"type":"listItem","spread":true,"position":{"start":{"line":254,"column":1},"end":{"line":254,"column":1}},"children":[{"type":"strong","position":{"start":{"line":254,"column":1},"end":{"line":254,"column":1}},"children":[{"type":"text","value":"Computational Cost","position":{"start":{"line":254,"column":1},"end":{"line":254,"column":1}},"key":"acmKCuDlpY"}],"key":"fDHR2Ij0B2"},{"type":"text","value":": Time each method for various timestep sizes","position":{"start":{"line":254,"column":1},"end":{"line":254,"column":1}},"key":"M9iK6SKjQX"}],"key":"srlcFzUSES"},{"type":"listItem","spread":true,"position":{"start":{"line":255,"column":1},"end":{"line":256,"column":1}},"children":[{"type":"strong","position":{"start":{"line":255,"column":1},"end":{"line":255,"column":1}},"children":[{"type":"text","value":"Long-term Stability","position":{"start":{"line":255,"column":1},"end":{"line":255,"column":1}},"key":"BLwLxqZeZD"}],"key":"GduuN6j3Zh"},{"type":"text","value":": Run for 10+ orbital periods","position":{"start":{"line":255,"column":1},"end":{"line":255,"column":1}},"key":"BYRwzTIP9d"}],"key":"Xd9Itt4Kwh"}],"key":"FZYov6ONMp"},{"type":"paragraph","position":{"start":{"line":257,"column":1},"end":{"line":257,"column":1}},"children":[{"type":"strong","position":{"start":{"line":257,"column":1},"end":{"line":257,"column":1}},"children":[{"type":"text","value":"Week 1 Deliverable","position":{"start":{"line":257,"column":1},"end":{"line":257,"column":1}},"key":"taQPRkqRSk"}],"key":"cFMVHe9k7w"},{"type":"text","value":": ODE solver library with comprehensive validation on Kepler orbits","position":{"start":{"line":257,"column":1},"end":{"line":257,"column":1}},"key":"uTdB9wbR3c"}],"key":"qI1YOsTOk1"},{"type":"thematicBreak","position":{"start":{"line":259,"column":1},"end":{"line":259,"column":1}},"key":"k89wsV7CJM"},{"type":"heading","depth":2,"position":{"start":{"line":261,"column":1},"end":{"line":261,"column":1}},"children":[{"type":"text","value":"Week 2: Statistical Sampling and Multi-Body Systems","position":{"start":{"line":261,"column":1},"end":{"line":261,"column":1}},"key":"AAEIcPyTqQ"}],"identifier":"week-2-statistical-sampling-and-multi-body-systems","label":"Week 2: Statistical Sampling and Multi-Body Systems","html_id":"week-2-statistical-sampling-and-multi-body-systems","implicit":true,"key":"EMKsw6wL6n"},{"type":"heading","depth":3,"position":{"start":{"line":263,"column":1},"end":{"line":263,"column":1}},"children":[{"type":"text","value":"Conceptual Introduction (25 min)","position":{"start":{"line":263,"column":1},"end":{"line":263,"column":1}},"key":"pzMAH0MFHO"}],"identifier":"conceptual-introduction-25-min","label":"Conceptual Introduction (25 min)","html_id":"conceptual-introduction-25-min-1","implicit":true,"key":"xKfnwaEPnc"},{"type":"list","ordered":false,"spread":false,"position":{"start":{"line":264,"column":1},"end":{"line":268,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":264,"column":1},"end":{"line":264,"column":1}},"children":[{"type":"text","value":"Stellar Initial Mass Function: Salpeter, Kroupa, Chabrier prescriptions","position":{"start":{"line":264,"column":1},"end":{"line":264,"column":1}},"key":"PJJ7HezIE8"}],"key":"DrdjuGaK3Z"},{"type":"listItem","spread":true,"position":{"start":{"line":265,"column":1},"end":{"line":265,"column":1}},"children":[{"type":"text","value":"Spatial distributions in star clusters: Plummer sphere, King profiles","position":{"start":{"line":265,"column":1},"end":{"line":265,"column":1}},"key":"cuc43ntRs7"}],"key":"hrUQAuTVc8"},{"type":"listItem","spread":true,"position":{"start":{"line":266,"column":1},"end":{"line":266,"column":1}},"children":[{"type":"text","value":"Statistical sampling techniques: inverse transform, rejection sampling","position":{"start":{"line":266,"column":1},"end":{"line":266,"column":1}},"key":"BdwZjOaXRK"}],"key":"SI7j16Dkct"},{"type":"listItem","spread":true,"position":{"start":{"line":267,"column":1},"end":{"line":268,"column":1}},"children":[{"type":"text","value":"Virial equilibrium and cluster dynamics","position":{"start":{"line":267,"column":1},"end":{"line":267,"column":1}},"key":"eemCnaEz9M"}],"key":"pHZ5dTA3Sb"}],"key":"zU7vo4AMhV"},{"type":"heading","depth":3,"position":{"start":{"line":269,"column":1},"end":{"line":269,"column":1}},"children":[{"type":"text","value":"Lab Session Objectives","position":{"start":{"line":269,"column":1},"end":{"line":269,"column":1}},"key":"MX7vYv0ash"}],"identifier":"lab-session-objectives","label":"Lab Session Objectives","html_id":"lab-session-objectives-1","implicit":true,"key":"MDfh7OXMXR"},{"type":"paragraph","position":{"start":{"line":270,"column":1},"end":{"line":270,"column":1}},"children":[{"type":"text","value":"Implement realistic stellar cluster initialization and scale to many-body systems.","position":{"start":{"line":270,"column":1},"end":{"line":270,"column":1}},"key":"fO0YZYGu0T"}],"key":"vgqsacnqDI"},{"type":"heading","depth":4,"position":{"start":{"line":272,"column":1},"end":{"line":272,"column":1}},"children":[{"type":"text","value":"Task 1: Initial Mass Function Implementation (50 min)","position":{"start":{"line":272,"column":1},"end":{"line":272,"column":1}},"key":"XNarpwENXI"}],"identifier":"task-1-initial-mass-function-implementation-50-min","label":"Task 1: Initial Mass Function Implementation (50 min)","html_id":"task-1-initial-mass-function-implementation-50-min","implicit":true,"key":"YIfGtEwMYa"},{"type":"paragraph","position":{"start":{"line":273,"column":1},"end":{"line":273,"column":1}},"children":[{"type":"strong","position":{"start":{"line":273,"column":1},"end":{"line":273,"column":1}},"children":[{"type":"text","value":"Goal","position":{"start":{"line":273,"column":1},"end":{"line":273,"column":1}},"key":"YRLxzjkmT6"}],"key":"jAYQina15d"},{"type":"text","value":": Sample realistic stellar mass distributions","position":{"start":{"line":273,"column":1},"end":{"line":273,"column":1}},"key":"n6BYkeZrGw"}],"key":"sOPMWfbDDJ"},{"type":"paragraph","position":{"start":{"line":275,"column":1},"end":{"line":275,"column":1}},"children":[{"type":"strong","position":{"start":{"line":275,"column":1},"end":{"line":275,"column":1}},"children":[{"type":"text","value":"IMF Theory and Implementation","position":{"start":{"line":275,"column":1},"end":{"line":275,"column":1}},"key":"FCPjXsGn64"}],"key":"ZJVrO4kraM"},{"type":"text","value":":","position":{"start":{"line":275,"column":1},"end":{"line":275,"column":1}},"key":"tdShCUO9GY"}],"key":"oPIExxCKIW"},{"type":"code","lang":"python","value":"class StellarIMF:\n    \"\"\"\n    Stellar Initial Mass Function implementation.\n    \n    Supports multiple functional forms used in astrophysics.\n    \"\"\"\n    \n    def __init__(self, imf_type='kroupa', mass_range=(0.08, 120)):\n        \"\"\"\n        Parameters:\n        -----------\n        imf_type : str\n            'salpeter', 'kroupa', or 'chabrier'\n        mass_range : tuple\n            (minimum_mass, maximum_mass) in solar masses\n        \"\"\"\n        self.imf_type = imf_type\n        self.m_min, self.m_max = mass_range\n        self.normalization = self._calculate_normalization()\n    \n    def pdf(self, mass):\n        \"\"\"\n        Probability density function dN/dM.\n        \n        Salpeter (1955): dN/dM ∝ M^(-2.35)\n        Kroupa (2001): dN/dM ∝ M^(-1.3) for M < 0.5 M☉\n                               M^(-2.3) for M > 0.5 M☉\n        \"\"\"\n        mass = np.asarray(mass)\n        \n        if self.imf_type == 'salpeter':\n            return mass**(-2.35)\n        \n        elif self.imf_type == 'kroupa':\n            # Broken power law\n            result = np.zeros_like(mass)\n            low_mass = mass < 0.5\n            high_mass = mass >= 0.5\n            \n            result[low_mass] = mass[low_mass]**(-1.3)\n            # Ensure continuity at M = 0.5\n            normalization = 0.5**(-1.3 + 2.3)\n            result[high_mass] = normalization * mass[high_mass]**(-2.3)\n            \n            return result\n        \n        elif self.imf_type == 'chabrier':\n            # Log-normal for low masses + power law for high masses\n            # Implementation left as advanced exercise\n            pass\n    \n    def cdf(self, mass):\n        \"\"\"Cumulative distribution function.\"\"\"\n        # Analytical when possible, numerical integration otherwise\n        if self.imf_type == 'salpeter':\n            # CDF ∝ M^(-1.35)\n            return (mass**(-1.35) - self.m_min**(-1.35)) / \\\n                   (self.m_max**(-1.35) - self.m_min**(-1.35))\n    \n    def sample_rejection(self, n_stars):\n        \"\"\"Sample using rejection method.\"\"\"\n        masses = []\n        max_pdf = self.pdf(self.m_min)  # Maximum of PDF\n        \n        while len(masses) < n_stars:\n            # Propose random mass in range\n            m_proposal = self.m_min + (self.m_max - self.m_min) * np.random.random()\n            \n            # Accept with probability proportional to PDF\n            if np.random.random() < self.pdf(m_proposal) / max_pdf:\n                masses.append(m_proposal)\n        \n        return np.array(masses)\n    \n    def sample_inverse_transform(self, n_stars):\n        \"\"\"Sample using inverse CDF (when available).\"\"\"\n        if self.imf_type == 'salpeter':\n            u = np.random.random(n_stars)\n            # Invert CDF analytically\n            return (self.m_min**(-1.35) + u * (self.m_max**(-1.35) - self.m_min**(-1.35)))**(-1/1.35)\n        else:\n            # Fall back to rejection sampling\n            return self.sample_rejection(n_stars)\n    \n    def validate_distribution(self, masses, n_bins=50):\n        \"\"\"Compare sampled masses with theoretical IMF.\"\"\"\n        # Create histogram and compare with PDF\n        # Plot and calculate goodness-of-fit statistics\n        pass\n\ndef mass_to_stellar_properties(masses):\n    \"\"\"\n    Convert stellar masses to observable properties.\n    Uses Project 1 stellar physics relationships.\n    \"\"\"\n    # Mass-luminosity relation\n    luminosities = np.where(masses > 1.0, \n                           masses**3.5,  # High mass: L ∝ M^3.5\n                           masses**4.0)  # Low mass: L ∝ M^4.0\n    \n    # Mass-temperature relation (main sequence)\n    temperatures = 5778 * (masses)**0.5  # Rough approximation\n    \n    # Mass-radius relation\n    radii = np.where(masses > 1.0,\n                    masses**0.8,   # High mass\n                    masses**0.9)   # Low mass\n    \n    return {\n        'luminosities': luminosities,\n        'temperatures': temperatures,\n        'radii': radii\n    }","position":{"start":{"line":276,"column":1},"end":{"line":390,"column":1}},"key":"I2yTRv0rQX"},{"type":"heading","depth":4,"position":{"start":{"line":392,"column":1},"end":{"line":392,"column":1}},"children":[{"type":"text","value":"Task 2: Plummer Sphere Spatial Distribution (45 min)","position":{"start":{"line":392,"column":1},"end":{"line":392,"column":1}},"key":"fA0iMeA3Qe"}],"identifier":"task-2-plummer-sphere-spatial-distribution-45-min","label":"Task 2: Plummer Sphere Spatial Distribution (45 min)","html_id":"task-2-plummer-sphere-spatial-distribution-45-min","implicit":true,"key":"bds4Amdqwf"},{"type":"paragraph","position":{"start":{"line":393,"column":1},"end":{"line":393,"column":1}},"children":[{"type":"strong","position":{"start":{"line":393,"column":1},"end":{"line":393,"column":1}},"children":[{"type":"text","value":"Goal","position":{"start":{"line":393,"column":1},"end":{"line":393,"column":1}},"key":"jfj2JJE9Cn"}],"key":"XtHguzceCF"},{"type":"text","value":": Sample realistic 3D stellar cluster geometry","position":{"start":{"line":393,"column":1},"end":{"line":393,"column":1}},"key":"U8p5cgEi58"}],"key":"W8BPXLiCHT"},{"type":"paragraph","position":{"start":{"line":395,"column":1},"end":{"line":395,"column":1}},"children":[{"type":"strong","position":{"start":{"line":395,"column":1},"end":{"line":395,"column":1}},"children":[{"type":"text","value":"Plummer Model Implementation","position":{"start":{"line":395,"column":1},"end":{"line":395,"column":1}},"key":"FAeJEYUyVI"}],"key":"lfPbMoGj8D"},{"type":"text","value":":","position":{"start":{"line":395,"column":1},"end":{"line":395,"column":1}},"key":"Gi7JyerQ8X"}],"key":"os0d4BceFI"},{"type":"code","lang":"python","value":"class PlummerSphere:\n    \"\"\"\n    Plummer sphere model for stellar cluster spatial distribution.\n    \n    Density profile: ρ(r) = (3M/4πa³) * (1 + r²/a²)^(-5/2)\n    where a is the scale radius.\n    \"\"\"\n    \n    def __init__(self, total_mass=1000, scale_radius=1.0):\n        \"\"\"\n        Parameters:\n        -----------\n        total_mass : float\n            Total cluster mass [M☉]\n        scale_radius : float\n            Plummer scale radius [pc]\n        \"\"\"\n        self.M = total_mass\n        self.a = scale_radius\n    \n    def density(self, r):\n        \"\"\"Density at radius r.\"\"\"\n        return (3*self.M/(4*np.pi*self.a**3)) * (1 + (r/self.a)**2)**(-5/2)\n    \n    def mass_enclosed(self, r):\n        \"\"\"Mass within radius r.\"\"\"\n        return self.M * (r/self.a)**3 / (1 + (r/self.a)**2)**(3/2)\n    \n    def sample_radial_positions(self, n_stars):\n        \"\"\"\n        Sample radial distances using inverse CDF method.\n        \n        CDF: M(r)/M_total = (r/a)³ / (1 + (r/a)²)^(3/2)\n        Inverse: r = a / sqrt(u^(-2/3) - 1)\n        \"\"\"\n        u = np.random.random(n_stars)\n        # Prevent u=0 which gives infinite radius\n        u = np.clip(u, 1e-10, 1-1e-10)\n        \n        radii = self.a / np.sqrt(u**(-2/3) - 1)\n        return radii\n    \n    def sample_positions(self, n_stars):\n        \"\"\"Sample 3D positions from Plummer distribution.\"\"\"\n        radii = self.sample_radial_positions(n_stars)\n        \n        # Sample isotropic directions\n        cos_theta = 2*np.random.random(n_stars) - 1  # cos(θ) uniform in [-1,1]\n        phi = 2*np.pi*np.random.random(n_stars)      # φ uniform in [0,2π]\n        \n        sin_theta = np.sqrt(1 - cos_theta**2)\n        \n        # Convert to Cartesian coordinates\n        x = radii * sin_theta * np.cos(phi)\n        y = radii * sin_theta * np.sin(phi)\n        z = radii * cos_theta\n        \n        return np.column_stack([x, y, z])\n    \n    def calculate_virial_velocities(self, positions, masses):\n        \"\"\"\n        Calculate velocities for virial equilibrium.\n        \n        Uses virial theorem: 2T + U = 0 for bound system\n        where T = kinetic energy, U = potential energy\n        \"\"\"\n        n_stars = len(masses)\n        velocities = np.zeros_like(positions)\n        \n        # Calculate potential energy\n        U = 0\n        for i in range(n_stars):\n            for j in range(i+1, n_stars):\n                r_ij = np.linalg.norm(positions[i] - positions[j])\n                U -= G * masses[i] * masses[j] / r_ij\n        \n        # Virial theorem: total kinetic energy = -U/2\n        T_total = -U / 2\n        \n        # Distribute kinetic energy among particles\n        # Simple approach: assume isotropic velocity dispersion\n        for i in range(n_stars):\n            # Individual kinetic energy proportional to mass\n            T_i = T_total * masses[i] / np.sum(masses)\n            v_mag = np.sqrt(2 * T_i / masses[i])\n            \n            # Random direction\n            cos_theta = 2*np.random.random() - 1\n            phi = 2*np.pi*np.random.random()\n            sin_theta = np.sqrt(1 - cos_theta**2)\n            \n            velocities[i] = v_mag * np.array([\n                sin_theta * np.cos(phi),\n                sin_theta * np.sin(phi),\n                cos_theta\n            ])\n        \n        return velocities","position":{"start":{"line":396,"column":1},"end":{"line":495,"column":1}},"key":"oxSjL9vuva"},{"type":"heading","depth":4,"position":{"start":{"line":497,"column":1},"end":{"line":497,"column":1}},"children":[{"type":"text","value":"Task 3: Vectorized N-Body Force Calculation (40 min)","position":{"start":{"line":497,"column":1},"end":{"line":497,"column":1}},"key":"w8JmEU9Lnq"}],"identifier":"task-3-vectorized-n-body-force-calculation-40-min","label":"Task 3: Vectorized N-Body Force Calculation (40 min)","html_id":"task-3-vectorized-n-body-force-calculation-40-min","implicit":true,"key":"RzwnezYmPg"},{"type":"paragraph","position":{"start":{"line":498,"column":1},"end":{"line":498,"column":1}},"children":[{"type":"strong","position":{"start":{"line":498,"column":1},"end":{"line":498,"column":1}},"children":[{"type":"text","value":"Goal","position":{"start":{"line":498,"column":1},"end":{"line":498,"column":1}},"key":"H1OwbVSMY0"}],"key":"ePfLqk3cWP"},{"type":"text","value":": Implement efficient O(N²) force computation","position":{"start":{"line":498,"column":1},"end":{"line":498,"column":1}},"key":"gTaK8OwCf7"}],"key":"Xh2MSgQrD3"},{"type":"paragraph","position":{"start":{"line":500,"column":1},"end":{"line":500,"column":1}},"children":[{"type":"strong","position":{"start":{"line":500,"column":1},"end":{"line":500,"column":1}},"children":[{"type":"text","value":"Vectorized Implementation","position":{"start":{"line":500,"column":1},"end":{"line":500,"column":1}},"key":"PxCyKW0ozQ"}],"key":"n7BFNTNDVP"},{"type":"text","value":":","position":{"start":{"line":500,"column":1},"end":{"line":500,"column":1}},"key":"LSm8fYsg7I"}],"key":"BLo5JqCDpG"},{"type":"code","lang":"python","value":"def gravitational_forces_vectorized(positions, masses, softening=0.01):\n    \"\"\"\n    Calculate gravitational forces between all particle pairs.\n    \n    Parameters:\n    -----------\n    positions : array [N, 3]\n        Particle positions\n    masses : array [N]\n        Particle masses\n    softening : float\n        Softening parameter to avoid singularities\n        \n    Returns:\n    --------\n    forces : array [N, 3]\n        Gravitational forces on each particle\n    \"\"\"\n    N = len(masses)\n    G = 4.3e-3  # pc³/M☉/Myr² (convenient units)\n    \n    # Calculate all pairwise separations using broadcasting\n    # positions[i,j] - positions[k,j] for all i,k pairs\n    r_vectors = positions[:, np.newaxis, :] - positions[np.newaxis, :, :]  # [N, N, 3]\n    \n    # Distance magnitudes with softening\n    r_magnitudes = np.sqrt(np.sum(r_vectors**2, axis=2) + softening**2)  # [N, N]\n    \n    # Avoid self-interaction\n    np.fill_diagonal(r_magnitudes, np.inf)\n    \n    # Force magnitudes: F = G*m1*m2/r²\n    mass_products = masses[:, np.newaxis] * masses[np.newaxis, :]  # [N, N]\n    force_magnitudes = G * mass_products / r_magnitudes**2  # [N, N]\n    \n    # Force directions: unit vectors\n    r_unit = r_vectors / r_magnitudes[:, :, np.newaxis]  # [N, N, 3]\n    \n    # Total forces: sum over all other particles\n    forces = np.sum(force_magnitudes[:, :, np.newaxis] * r_unit, axis=1)  # [N, 3]\n    \n    return forces\n\ndef performance_comparison():\n    \"\"\"Compare vectorized vs nested loop implementations.\"\"\"\n    import time\n    \n    # Test different cluster sizes\n    N_values = [10, 50, 100, 200, 500]\n    \n    for N in N_values:\n        # Generate test data\n        positions = np.random.randn(N, 3)\n        masses = np.random.uniform(0.1, 10, N)\n        \n        # Time vectorized version\n        start = time.time()\n        forces_vec = gravitational_forces_vectorized(positions, masses)\n        time_vec = time.time() - start\n        \n        # Time nested loop version (for comparison)\n        start = time.time()\n        forces_loop = gravitational_forces_nested_loops(positions, masses)\n        time_loop = time.time() - start\n        \n        print(f\"N={N}: Vectorized={time_vec:.4f}s, Loops={time_loop:.4f}s, \"\n              f\"Speedup={time_loop/time_vec:.1f}x\")","position":{"start":{"line":501,"column":1},"end":{"line":569,"column":1}},"key":"nTs9r3dCVU"},{"type":"paragraph","position":{"start":{"line":571,"column":1},"end":{"line":571,"column":1}},"children":[{"type":"strong","position":{"start":{"line":571,"column":1},"end":{"line":571,"column":1}},"children":[{"type":"text","value":"Week 2 Deliverable","position":{"start":{"line":571,"column":1},"end":{"line":571,"column":1}},"key":"GLBwZSESmD"}],"key":"I4EKBq8juR"},{"type":"text","value":": Realistic stellar cluster initialization with IMF masses and Plummer positions, plus efficient force calculations","position":{"start":{"line":571,"column":1},"end":{"line":571,"column":1}},"key":"O8nQuoAfDK"}],"key":"xWgETgkmm1"},{"type":"thematicBreak","position":{"start":{"line":573,"column":1},"end":{"line":573,"column":1}},"key":"cPt3qB1yjl"},{"type":"heading","depth":2,"position":{"start":{"line":575,"column":1},"end":{"line":575,"column":1}},"children":[{"type":"text","value":"Week 3: Adaptive Timestepping and Cluster Evolution","position":{"start":{"line":575,"column":1},"end":{"line":575,"column":1}},"key":"QeKn42X70M"}],"identifier":"week-3-adaptive-timestepping-and-cluster-evolution","label":"Week 3: Adaptive Timestepping and Cluster Evolution","html_id":"week-3-adaptive-timestepping-and-cluster-evolution","implicit":true,"key":"EBK2WCaR1t"},{"type":"heading","depth":3,"position":{"start":{"line":577,"column":1},"end":{"line":577,"column":1}},"children":[{"type":"text","value":"Conceptual Introduction (25 min)","position":{"start":{"line":577,"column":1},"end":{"line":577,"column":1}},"key":"EwJFeL3ptK"}],"identifier":"conceptual-introduction-25-min","label":"Conceptual Introduction (25 min)","html_id":"conceptual-introduction-25-min-2","implicit":true,"key":"vOqtLQoXoT"},{"type":"list","ordered":false,"spread":false,"position":{"start":{"line":578,"column":1},"end":{"line":583,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":578,"column":1},"end":{"line":578,"column":1}},"children":[{"type":"text","value":"Energy conservation as accuracy criterion","position":{"start":{"line":578,"column":1},"end":{"line":578,"column":1}},"key":"fHepJY56ep"}],"key":"EDIQog2Q7J"},{"type":"listItem","spread":true,"position":{"start":{"line":579,"column":1},"end":{"line":579,"column":1}},"children":[{"type":"text","value":"Adaptive timestep algorithms","position":{"start":{"line":579,"column":1},"end":{"line":579,"column":1}},"key":"DOoBbjjSXR"}],"key":"B8d4lXuf01"},{"type":"listItem","spread":true,"position":{"start":{"line":580,"column":1},"end":{"line":580,"column":1}},"children":[{"type":"text","value":"Multi-mass cluster dynamics: mass segregation, two-body relaxation","position":{"start":{"line":580,"column":1},"end":{"line":580,"column":1}},"key":"qoe8Lu4IiB"}],"key":"foh3grmKgN"},{"type":"listItem","spread":true,"position":{"start":{"line":581,"column":1},"end":{"line":581,"column":1}},"children":[{"type":"text","value":"Stellar escape and cluster dissolution","position":{"start":{"line":581,"column":1},"end":{"line":581,"column":1}},"key":"oP50p8YFoP"}],"key":"j6WkXPicVO"},{"type":"listItem","spread":true,"position":{"start":{"line":582,"column":1},"end":{"line":583,"column":1}},"children":[{"type":"text","value":"Computational complexity and optimization strategies","position":{"start":{"line":582,"column":1},"end":{"line":582,"column":1}},"key":"PEY79JUggi"}],"key":"Ap3QehHXzy"}],"key":"LDOvbEWjfy"},{"type":"heading","depth":3,"position":{"start":{"line":584,"column":1},"end":{"line":584,"column":1}},"children":[{"type":"text","value":"Lab Session Objectives","position":{"start":{"line":584,"column":1},"end":{"line":584,"column":1}},"key":"F58peTwsXw"}],"identifier":"lab-session-objectives","label":"Lab Session Objectives","html_id":"lab-session-objectives-2","implicit":true,"key":"a4N0ISYh21"},{"type":"paragraph","position":{"start":{"line":585,"column":1},"end":{"line":585,"column":1}},"children":[{"type":"text","value":"Implement energy-controlled adaptive integration and study realistic cluster evolution.","position":{"start":{"line":585,"column":1},"end":{"line":585,"column":1}},"key":"aVvzMjRbD1"}],"key":"A5i1w0KV7U"},{"type":"heading","depth":4,"position":{"start":{"line":587,"column":1},"end":{"line":587,"column":1}},"children":[{"type":"text","value":"Task 1: Adaptive Timestep Control (50 min)","position":{"start":{"line":587,"column":1},"end":{"line":587,"column":1}},"key":"Ugqcu8APtD"}],"identifier":"task-1-adaptive-timestep-control-50-min","label":"Task 1: Adaptive Timestep Control (50 min)","html_id":"task-1-adaptive-timestep-control-50-min","implicit":true,"key":"AmnPoGaIp4"},{"type":"paragraph","position":{"start":{"line":588,"column":1},"end":{"line":588,"column":1}},"children":[{"type":"strong","position":{"start":{"line":588,"column":1},"end":{"line":588,"column":1}},"children":[{"type":"text","value":"Goal","position":{"start":{"line":588,"column":1},"end":{"line":588,"column":1}},"key":"TcVczgKosA"}],"key":"kPRGrEZePl"},{"type":"text","value":": Implement robust adaptive timestep algorithm based on energy conservation","position":{"start":{"line":588,"column":1},"end":{"line":588,"column":1}},"key":"eqy34RK45e"}],"key":"UlyqyzwDjt"},{"type":"paragraph","position":{"start":{"line":590,"column":1},"end":{"line":590,"column":1}},"children":[{"type":"strong","position":{"start":{"line":590,"column":1},"end":{"line":590,"column":1}},"children":[{"type":"text","value":"Adaptive Integration Framework","position":{"start":{"line":590,"column":1},"end":{"line":590,"column":1}},"key":"fOYaZusCDc"}],"key":"JbD6CSHZ6x"},{"type":"text","value":":","position":{"start":{"line":590,"column":1},"end":{"line":590,"column":1}},"key":"uAHvZnt0q5"}],"key":"F5BAxvtB4v"},{"type":"code","lang":"python","value":"class AdaptiveNBodySimulator:\n    \"\"\"\n    N-body simulator with adaptive timestep control.\n    \n    Uses energy conservation to monitor accuracy and adjust timestep.\n    \"\"\"\n    \n    def __init__(self, positions, velocities, masses, initial_dt=0.01, \n                 energy_tolerance=1e-6):\n        \"\"\"\n        Parameters:\n        -----------\n        positions : array [N, 3]\n            Initial positions [pc]\n        velocities : array [N, 3] \n            Initial velocities [km/s]\n        masses : array [N]\n            Particle masses [M☉]\n        initial_dt : float\n            Initial timestep [Myr]\n        energy_tolerance : float\n            Relative energy error tolerance\n        \"\"\"\n        self.positions = np.array(positions)\n        self.velocities = np.array(velocities) \n        self.masses = np.array(masses)\n        self.dt = initial_dt\n        self.tolerance = energy_tolerance\n        \n        # Calculate initial energy\n        self.initial_energy = self.total_energy()\n        \n        # Statistics tracking\n        self.n_accepted = 0\n        self.n_rejected = 0\n        self.energy_errors = []\n        self.timesteps = []\n        \n        # History storage\n        self.time = 0.0\n        self.history = {\n            'time': [0.0],\n            'positions': [self.positions.copy()],\n            'velocities': [self.velocities.copy()],\n            'energy': [self.initial_energy],\n            'timestep': [self.dt]\n        }\n    \n    def total_energy(self):\n        \"\"\"Calculate total energy: kinetic + potential.\"\"\"\n        # Kinetic energy\n        ke = 0.5 * np.sum(self.masses * np.sum(self.velocities**2, axis=1))\n        \n        # Potential energy\n        pe = 0\n        for i in range(len(self.masses)):\n            for j in range(i+1, len(self.masses)):\n                r_ij = np.linalg.norm(self.positions[i] - self.positions[j])\n                pe -= G * self.masses[i] * self.masses[j] / r_ij\n        \n        return ke + pe\n    \n    def energy_error(self):\n        \"\"\"Calculate relative energy error from initial value.\"\"\"\n        current_energy = self.total_energy()\n        return abs((current_energy - self.initial_energy) / self.initial_energy)\n    \n    def leapfrog_step(self, dt):\n        \"\"\"Take single leapfrog integration step.\"\"\"\n        # Store initial state for potential rollback\n        old_positions = self.positions.copy()\n        old_velocities = self.velocities.copy()\n        \n        # Leapfrog integration\n        forces = gravitational_forces_vectorized(self.positions, self.masses)\n        accelerations = forces / self.masses[:, np.newaxis]\n        \n        # Kick-drift-kick\n        self.velocities += 0.5 * dt * accelerations\n        self.positions += dt * self.velocities\n        \n        forces = gravitational_forces_vectorized(self.positions, self.masses)\n        accelerations = forces / self.masses[:, np.newaxis]\n        self.velocities += 0.5 * dt * accelerations\n        \n        return old_positions, old_velocities\n    \n    def adaptive_step(self):\n        \"\"\"\n        Take adaptive timestep with error control.\n        \n        Algorithm:\n        1. Attempt step with current timestep\n        2. Check energy conservation\n        3. If error too large: reduce timestep and retry\n        4. If error acceptable: possibly increase timestep for next step\n        \"\"\"\n        max_attempts = 5\n        \n        for attempt in range(max_attempts):\n            # Store state before step\n            old_positions, old_velocities = self.leapfrog_step(self.dt)\n            \n            # Check energy conservation\n            error = self.energy_error()\n            \n            if error <= self.tolerance:\n                # Step accepted\n                self.time += self.dt\n                self.n_accepted += 1\n                \n                # Store results\n                self.history['time'].append(self.time)\n                self.history['positions'].append(self.positions.copy())\n                self.history['velocities'].append(self.velocities.copy())\n                self.history['energy'].append(self.total_energy())\n                self.history['timestep'].append(self.dt)\n                \n                self.energy_errors.append(error)\n                self.timesteps.append(self.dt)\n                \n                # Possibly increase timestep for next step\n                if error < self.tolerance / 10:\n                    self.dt = min(self.dt * 1.1, 0.1)  # Don't let it grow too large\n                \n                return True\n            \n            else:\n                # Step rejected - restore state and reduce timestep\n                self.positions = old_positions\n                self.velocities = old_velocities\n                self.dt *= 0.5\n                self.n_rejected += 1\n                \n                if attempt == max_attempts - 1:\n                    print(f\"Warning: Max attempts reached at t={self.time:.3f}\")\n                    return False\n        \n        return False\n    \n    def evolve(self, t_final, max_steps=10000):\n        \"\"\"Evolve system to final time using adaptive timesteps.\"\"\"\n        step_count = 0\n        \n        while self.time < t_final and step_count < max_steps:\n            success = self.adaptive_step()\n            if not success:\n                print(\"Simulation failed - energy errors too large\")\n                break\n            \n            step_count += 1\n            \n            # Progress reporting\n            if step_count % 100 == 0:\n                acceptance_rate = self.n_accepted / (self.n_accepted + self.n_rejected)\n                print(f\"t={self.time:.2f}, dt={self.dt:.4f}, \"\n                      f\"E_error={self.energy_errors[-1]:.2e}, \"\n                      f\"acceptance={acceptance_rate:.2f}\")\n        \n        return self.get_results()\n    \n    def get_results(self):\n        \"\"\"Return simulation results as arrays.\"\"\"\n        return {\n            'time': np.array(self.history['time']),\n            'positions': np.array(self.history['positions']),\n            'velocities': np.array(self.history['velocities']),\n            'energy': np.array(self.history['energy']),\n            'timesteps': np.array(self.history['timestep'])\n        }","position":{"start":{"line":591,"column":1},"end":{"line":762,"column":1}},"key":"CsFrFAkRmp"},{"type":"heading","depth":4,"position":{"start":{"line":764,"column":1},"end":{"line":764,"column":1}},"children":[{"type":"text","value":"Task 2: Cluster Physics and Evolution (55 min)","position":{"start":{"line":764,"column":1},"end":{"line":764,"column":1}},"key":"tgE9rrlOiR"}],"identifier":"task-2-cluster-physics-and-evolution-55-min","label":"Task 2: Cluster Physics and Evolution (55 min)","html_id":"task-2-cluster-physics-and-evolution-55-min","implicit":true,"key":"bDCKsuyiUz"},{"type":"paragraph","position":{"start":{"line":765,"column":1},"end":{"line":765,"column":1}},"children":[{"type":"strong","position":{"start":{"line":765,"column":1},"end":{"line":765,"column":1}},"children":[{"type":"text","value":"Goal","position":{"start":{"line":765,"column":1},"end":{"line":765,"column":1}},"key":"a0kYk8StOd"}],"key":"hcvIsMgBgb"},{"type":"text","value":": Study realistic stellar cluster evolution phenomena","position":{"start":{"line":765,"column":1},"end":{"line":765,"column":1}},"key":"iKnhYg6E81"}],"key":"bTZgrG5Bfc"},{"type":"paragraph","position":{"start":{"line":767,"column":1},"end":{"line":767,"column":1}},"children":[{"type":"strong","position":{"start":{"line":767,"column":1},"end":{"line":767,"column":1}},"children":[{"type":"text","value":"Mass Segregation Analysis","position":{"start":{"line":767,"column":1},"end":{"line":767,"column":1}},"key":"o5FDw3onWH"}],"key":"NG3hnKKb8Q"},{"type":"text","value":":","position":{"start":{"line":767,"column":1},"end":{"line":767,"column":1}},"key":"TEV91GlOA2"}],"key":"JZFuEoNdcm"},{"type":"code","lang":"python","value":"def analyze_mass_segregation(positions, masses, times):\n    \"\"\"\n    Track mass segregation: massive stars sink to cluster center.\n    \n    Quantify using mass-weighted radial distribution.\n    \"\"\"\n    segregation_ratios = []\n    \n    for i, pos in enumerate(positions):\n        # Calculate distance from cluster center\n        center = np.average(pos, weights=masses, axis=0)\n        distances = np.linalg.norm(pos - center, axis=1)\n        \n        # Sort by mass\n        mass_order = np.argsort(masses)[::-1]  # Heaviest first\n        \n        # Compare radial distribution of most vs least massive stars\n        n_heavy = len(masses) // 10  # Top 10%\n        n_light = len(masses) // 10  # Bottom 10%\n        \n        r_heavy = np.mean(distances[mass_order[:n_heavy]])\n        r_light = np.mean(distances[mass_order[-n_light:]])\n        \n        segregation_ratios.append(r_light / r_heavy)\n    \n    return segregation_ratios\n\ndef calculate_virial_ratio(positions, velocities, masses):\n    \"\"\"\n    Calculate virial ratio: 2T/|U|\n    \n    For bound system in equilibrium, should equal 1.\n    \"\"\"\n    # Kinetic energy\n    T = 0.5 * np.sum(masses * np.sum(velocities**2, axis=1))\n    \n    # Potential energy\n    U = 0\n    for i in range(len(masses)):\n        for j in range(i+1, len(masses)):\n            r_ij = np.linalg.norm(positions[i] - positions[j])\n            U -= G * masses[i] * masses[j] / r_ij\n    \n    return 2 * T / abs(U)\n\ndef identify_escaping_stars(positions, velocities, masses, escape_criterion=2.0):\n    \"\"\"\n    Identify stars with velocities exceeding escape velocity.\n    \n    v_escape = sqrt(2 * |U| / m) at each star's location\n    \"\"\"\n    escaping_stars = []\n    \n    for i in range(len(masses)):\n        # Calculate potential at star i due to all other stars\n        phi_i = 0\n        for j in range(len(masses)):\n            if i != j:\n                r_ij = np.linalg.norm(positions[i] - positions[j])\n                phi_i -= G * masses[j] / r_ij\n        \n        # Escape velocity at this location\n        v_escape = np.sqrt(-2 * phi_i)\n        v_star = np.linalg.norm(velocities[i])\n        \n        if v_star > escape_criterion * v_escape:\n            escaping_stars.append(i)\n    \n    return escaping_stars","position":{"start":{"line":768,"column":1},"end":{"line":838,"column":1}},"key":"kfQlsGkPB8"},{"type":"paragraph","position":{"start":{"line":840,"column":1},"end":{"line":840,"column":1}},"children":[{"type":"strong","position":{"start":{"line":840,"column":1},"end":{"line":840,"column":1}},"children":[{"type":"text","value":"Cluster Snapshot Generation for Project 3","position":{"start":{"line":840,"column":1},"end":{"line":840,"column":1}},"key":"LUZpSmUIom"}],"key":"Go0Ao6VT24"},{"type":"text","value":":","position":{"start":{"line":840,"column":1},"end":{"line":840,"column":1}},"key":"e02PpG9yuy"}],"key":"OUHXm7wXfy"},{"type":"code","lang":"python","value":"def generate_cluster_snapshots(cluster_mass=1000, n_stars=200, \n                              evolution_times=[0, 5, 20, 50]):\n    \"\"\"\n    Generate stellar cluster at multiple evolutionary phases.\n    These snapshots will be used in Project 3 for radiation calculations.\n    \n    Parameters:\n    -----------\n    cluster_mass : float\n        Total cluster mass [M☉]\n    n_stars : int\n        Number of stars in cluster\n    evolution_times : list\n        Times to save snapshots [Myr]\n        \n    Returns:\n    --------\n    snapshots : list of dict\n        Each dict contains stellar properties at one time\n    \"\"\"\n    # Initialize cluster\n    imf = StellarIMF(imf_type='kroupa')\n    masses = imf.sample_inverse_transform(n_stars)\n    masses = masses * (cluster_mass / np.sum(masses))  # Normalize total mass\n    \n    plummer = PlummerSphere(total_mass=cluster_mass, scale_radius=1.0)\n    positions = plummer.sample_positions(n_stars)\n    velocities = plummer.calculate_virial_velocities(positions, masses)\n    \n    # Calculate stellar properties for radiation (from Project 1)\n    stellar_props = mass_to_stellar_properties(masses)\n    \n    # Set up adaptive simulator\n    simulator = AdaptiveNBodySimulator(\n        positions, velocities, masses,\n        initial_dt=0.01, energy_tolerance=1e-6\n    )\n    \n    snapshots = []\n    \n    for t_target in evolution_times:\n        if t_target == 0:\n            # Initial conditions\n            snapshot = create_snapshot(\n                time=0, \n                positions=simulator.positions,\n                velocities=simulator.velocities,\n                masses=masses,\n                stellar_props=stellar_props\n            )\n        else:\n            # Evolve to target time\n            results = simulator.evolve(t_target)\n            \n            # Extract final state\n            final_positions = results['positions'][-1]\n            final_velocities = results['velocities'][-1]\n            \n            snapshot = create_snapshot(\n                time=t_target,\n                positions=final_positions,\n                velocities=final_velocities,\n                masses=masses,\n                stellar_props=stellar_props\n            )\n        \n        snapshots.append(snapshot)\n        print(f\"Snapshot created at t = {t_target} Myr\")\n    \n    return snapshots\n\ndef create_snapshot(time, positions, velocities, masses, stellar_props):\n    \"\"\"Create comprehensive cluster snapshot.\"\"\"\n    # Calculate cluster center and properties\n    center = np.average(positions, weights=masses, axis=0)\n    centered_positions = positions - center\n    \n    # Structural parameters\n    distances = np.linalg.norm(centered_positions, axis=1)\n    half_mass_radius = np.median(distances)\n    \n    # Core radius (radius containing 10% of mass)\n    mass_order = np.argsort(distances)\n    core_mass_index = int(0.1 * len(masses))\n    core_radius = distances[mass_order[core_mass_index]]\n    \n    snapshot = {\n        'time': time,\n        'n_stars': len(masses),\n        'total_mass': np.sum(masses),\n        \n        # Stellar properties\n        'positions': centered_positions,  # Centered on cluster\n        'velocities': velocities,\n        'masses': masses,\n        'luminosities': stellar_props['luminosities'],\n        'temperatures': stellar_props['temperatures'],\n        'radii': stellar_props['radii'],\n        \n        # Cluster structure\n        'center': center,\n        'half_mass_radius': half_mass_radius,\n        'core_radius': core_radius,\n        'virial_ratio': calculate_virial_ratio(positions, velocities, masses),\n        \n        # Evolution diagnostics\n        'mass_segregation_ratio': analyze_mass_segregation([positions], masses, [time])[0],\n        'escaping_stars': identify_escaping_stars(positions, velocities, masses)\n    }\n    \n    return snapshot\n\ndef save_snapshots_for_project3(snapshots, filename='cluster_evolution.pkl'):\n    \"\"\"Save snapshots in format suitable for Project 3.\"\"\"\n    import pickle\n    \n    with open(filename, 'wb') as f:\n        pickle.dump(snapshots, f)\n    \n    print(f\"Saved {len(snapshots)} cluster snapshots to {filename}\")\n    print(\"These will be used as radiation sources in Project 3\")","position":{"start":{"line":841,"column":1},"end":{"line":963,"column":1}},"key":"RNLMEH94fP"},{"type":"heading","depth":4,"position":{"start":{"line":965,"column":1},"end":{"line":965,"column":1}},"children":[{"type":"text","value":"Task 3: Performance Analysis and Optimization (30 min)","position":{"start":{"line":965,"column":1},"end":{"line":965,"column":1}},"key":"QOuTcTGNBj"}],"identifier":"task-3-performance-analysis-and-optimization-30-min","label":"Task 3: Performance Analysis and Optimization (30 min)","html_id":"task-3-performance-analysis-and-optimization-30-min","implicit":true,"key":"Een0LsWCEn"},{"type":"paragraph","position":{"start":{"line":966,"column":1},"end":{"line":966,"column":1}},"children":[{"type":"strong","position":{"start":{"line":966,"column":1},"end":{"line":966,"column":1}},"children":[{"type":"text","value":"Goal","position":{"start":{"line":966,"column":1},"end":{"line":966,"column":1}},"key":"XsCTlGcfQ0"}],"key":"FGf5MGaSm5"},{"type":"text","value":": Analyze computational efficiency and identify optimization opportunities","position":{"start":{"line":966,"column":1},"end":{"line":966,"column":1}},"key":"rrSDAS2su0"}],"key":"lhYzkxcPAg"},{"type":"paragraph","position":{"start":{"line":968,"column":1},"end":{"line":968,"column":1}},"children":[{"type":"strong","position":{"start":{"line":968,"column":1},"end":{"line":968,"column":1}},"children":[{"type":"text","value":"Performance Studies","position":{"start":{"line":968,"column":1},"end":{"line":968,"column":1}},"key":"m9tYc94maL"}],"key":"QVb5nH5Yoj"},{"type":"text","value":":","position":{"start":{"line":968,"column":1},"end":{"line":968,"column":1}},"key":"Fx4S9Cd5ue"}],"key":"Dj9gD8d0ph"},{"type":"code","lang":"python","value":"def scaling_analysis():\n    \"\"\"Study how computational cost scales with cluster size.\"\"\"\n    import time\n    \n    N_values = [50, 100, 200, 400]\n    times_force = []\n    times_integration = []\n    \n    for N in N_values:\n        # Generate test cluster\n        masses = np.random.uniform(0.1, 10, N)\n        positions = np.random.randn(N, 3)\n        velocities = np.random.randn(N, 3)\n        \n        # Time force calculation\n        start = time.time()\n        for _ in range(10):  # Multiple iterations for averaging\n            forces = gravitational_forces_vectorized(positions, masses)\n        times_force.append((time.time() - start) / 10)\n        \n        # Time full integration step\n        simulator = AdaptiveNBodySimulator(positions, velocities, masses)\n        start = time.time()\n        for _ in range(10):\n            simulator.adaptive_step()\n        times_integration.append((time.time() - start) / 10)\n    \n    # Analyze scaling: should be O(N²) for force calculation\n    print(\"Scaling Analysis:\")\n    for i, N in enumerate(N_values):\n        print(f\"N={N}: Force={times_force[i]:.4f}s, Integration={times_integration[i]:.4f}s\")\n\ndef memory_optimization_analysis():\n    \"\"\"Analyze memory usage and suggest optimizations.\"\"\"\n    # Profile memory usage during simulation\n    # Identify opportunities for optimization\n    pass","position":{"start":{"line":969,"column":1},"end":{"line":1007,"column":1}},"key":"M65uJTJqLs"},{"type":"paragraph","position":{"start":{"line":1009,"column":1},"end":{"line":1009,"column":1}},"children":[{"type":"strong","position":{"start":{"line":1009,"column":1},"end":{"line":1009,"column":1}},"children":[{"type":"text","value":"Week 3 Deliverable","position":{"start":{"line":1009,"column":1},"end":{"line":1009,"column":1}},"key":"mBryIX5ltw"}],"key":"aTIToI9CmB"},{"type":"text","value":": Complete adaptive N-body simulator with realistic cluster evolution and snapshots for Project 3","position":{"start":{"line":1009,"column":1},"end":{"line":1009,"column":1}},"key":"VWKWtx2fnY"}],"key":"wRDWBiBlvz"},{"type":"thematicBreak","position":{"start":{"line":1011,"column":1},"end":{"line":1011,"column":1}},"key":"UQbGn120xS"},{"type":"heading","depth":2,"position":{"start":{"line":1013,"column":1},"end":{"line":1013,"column":1}},"children":[{"type":"text","value":"Assessment and Grading","position":{"start":{"line":1013,"column":1},"end":{"line":1013,"column":1}},"key":"RNn0Ac7R2I"}],"identifier":"assessment-and-grading","label":"Assessment and Grading","html_id":"assessment-and-grading","implicit":true,"key":"ymvQg7MHJE"},{"type":"heading","depth":3,"position":{"start":{"line":1015,"column":1},"end":{"line":1015,"column":1}},"children":[{"type":"text","value":"Grading Breakdown","position":{"start":{"line":1015,"column":1},"end":{"line":1015,"column":1}},"key":"wKnVSHQZ0b"}],"identifier":"grading-breakdown","label":"Grading Breakdown","html_id":"grading-breakdown","implicit":true,"key":"CuxAs4dFJ2"},{"type":"list","ordered":false,"spread":false,"position":{"start":{"line":1016,"column":1},"end":{"line":1019,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":1016,"column":1},"end":{"line":1016,"column":1}},"children":[{"type":"strong","position":{"start":{"line":1016,"column":1},"end":{"line":1016,"column":1}},"children":[{"type":"text","value":"Week 1","position":{"start":{"line":1016,"column":1},"end":{"line":1016,"column":1}},"key":"fKcc3RNBkO"}],"key":"CMrfcARGeN"},{"type":"text","value":": ODE solvers and validation (30%)","position":{"start":{"line":1016,"column":1},"end":{"line":1016,"column":1}},"key":"b45xh7Zy04"}],"key":"xEamh9qWkP"},{"type":"listItem","spread":true,"position":{"start":{"line":1017,"column":1},"end":{"line":1017,"column":1}},"children":[{"type":"strong","position":{"start":{"line":1017,"column":1},"end":{"line":1017,"column":1}},"children":[{"type":"text","value":"Week 2","position":{"start":{"line":1017,"column":1},"end":{"line":1017,"column":1}},"key":"UjlvgAiSqC"}],"key":"vVVbiB3up0"},{"type":"text","value":": Statistical sampling and vectorization (35%)","position":{"start":{"line":1017,"column":1},"end":{"line":1017,"column":1}},"key":"sWCvHChI7z"}],"key":"cXIcI5qW9z"},{"type":"listItem","spread":true,"position":{"start":{"line":1018,"column":1},"end":{"line":1019,"column":1}},"children":[{"type":"strong","position":{"start":{"line":1018,"column":1},"end":{"line":1018,"column":1}},"children":[{"type":"text","value":"Week 3","position":{"start":{"line":1018,"column":1},"end":{"line":1018,"column":1}},"key":"GabWrAltfp"}],"key":"AzvaPGzg68"},{"type":"text","value":": Adaptive methods and cluster evolution (35%)","position":{"start":{"line":1018,"column":1},"end":{"line":1018,"column":1}},"key":"llXO1SPASd"}],"key":"NW9QtwnvjM"}],"key":"UyXbzvOZLE"},{"type":"heading","depth":3,"position":{"start":{"line":1020,"column":1},"end":{"line":1020,"column":1}},"children":[{"type":"text","value":"Evaluation Criteria","position":{"start":{"line":1020,"column":1},"end":{"line":1020,"column":1}},"key":"aaOBcqT8u3"}],"identifier":"evaluation-criteria","label":"Evaluation Criteria","html_id":"evaluation-criteria","implicit":true,"key":"wEQGXXkWqs"},{"type":"heading","depth":4,"position":{"start":{"line":1022,"column":1},"end":{"line":1022,"column":1}},"children":[{"type":"text","value":"Technical Implementation (60%)","position":{"start":{"line":1022,"column":1},"end":{"line":1022,"column":1}},"key":"dvUu5URL9i"}],"identifier":"technical-implementation-60","label":"Technical Implementation (60%)","html_id":"technical-implementation-60","implicit":true,"key":"qnIIL1szca"},{"type":"list","ordered":false,"spread":false,"position":{"start":{"line":1023,"column":1},"end":{"line":1027,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":1023,"column":1},"end":{"line":1023,"column":1}},"children":[{"type":"strong","position":{"start":{"line":1023,"column":1},"end":{"line":1023,"column":1}},"children":[{"type":"text","value":"Algorithm Correctness","position":{"start":{"line":1023,"column":1},"end":{"line":1023,"column":1}},"key":"csZSnuaSl7"}],"key":"qo6kIbMrln"},{"type":"text","value":": Do integrators conserve energy appropriately?","position":{"start":{"line":1023,"column":1},"end":{"line":1023,"column":1}},"key":"lyyxa160Sb"}],"key":"KRY4RHl4f3"},{"type":"listItem","spread":true,"position":{"start":{"line":1024,"column":1},"end":{"line":1024,"column":1}},"children":[{"type":"strong","position":{"start":{"line":1024,"column":1},"end":{"line":1024,"column":1}},"children":[{"type":"text","value":"Sampling Accuracy","position":{"start":{"line":1024,"column":1},"end":{"line":1024,"column":1}},"key":"a1R0v9JtJt"}],"key":"v8yA5Yve2C"},{"type":"text","value":": Do distributions match theoretical expectations?","position":{"start":{"line":1024,"column":1},"end":{"line":1024,"column":1}},"key":"N0BMpnm1b3"}],"key":"Lh7fi48pUo"},{"type":"listItem","spread":true,"position":{"start":{"line":1025,"column":1},"end":{"line":1025,"column":1}},"children":[{"type":"strong","position":{"start":{"line":1025,"column":1},"end":{"line":1025,"column":1}},"children":[{"type":"text","value":"Vectorization Efficiency","position":{"start":{"line":1025,"column":1},"end":{"line":1025,"column":1}},"key":"TfTdF2IZxz"}],"key":"kR9K2F4sPQ"},{"type":"text","value":": Significant speedup over naive implementations","position":{"start":{"line":1025,"column":1},"end":{"line":1025,"column":1}},"key":"VVeQgULf7Q"}],"key":"QcwwRGBzkT"},{"type":"listItem","spread":true,"position":{"start":{"line":1026,"column":1},"end":{"line":1027,"column":1}},"children":[{"type":"strong","position":{"start":{"line":1026,"column":1},"end":{"line":1026,"column":1}},"children":[{"type":"text","value":"Adaptive Control","position":{"start":{"line":1026,"column":1},"end":{"line":1026,"column":1}},"key":"ClmGjOBAE7"}],"key":"K7nh0p7c0k"},{"type":"text","value":": Proper timestep adjustment based on energy errors","position":{"start":{"line":1026,"column":1},"end":{"line":1026,"column":1}},"key":"elpBaHofNp"}],"key":"xQs89GEXdw"}],"key":"dBPLqCPI8w"},{"type":"heading","depth":4,"position":{"start":{"line":1028,"column":1},"end":{"line":1028,"column":1}},"children":[{"type":"text","value":"Scientific Understanding (25%)","position":{"start":{"line":1028,"column":1},"end":{"line":1028,"column":1}},"key":"w0enxZCSLA"}],"identifier":"scientific-understanding-25","label":"Scientific Understanding (25%)","html_id":"scientific-understanding-25","implicit":true,"key":"ibDveMeNNL"},{"type":"list","ordered":false,"spread":false,"position":{"start":{"line":1029,"column":1},"end":{"line":1032,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":1029,"column":1},"end":{"line":1029,"column":1}},"children":[{"type":"strong","position":{"start":{"line":1029,"column":1},"end":{"line":1029,"column":1}},"children":[{"type":"text","value":"Physics Validation","position":{"start":{"line":1029,"column":1},"end":{"line":1029,"column":1}},"key":"ETufemEfKs"}],"key":"jlWlK7AKQW"},{"type":"text","value":": Energy conservation, virial equilibrium, orbital mechanics","position":{"start":{"line":1029,"column":1},"end":{"line":1029,"column":1}},"key":"GD68ROJfp3"}],"key":"ju4gHyNRWI"},{"type":"listItem","spread":true,"position":{"start":{"line":1030,"column":1},"end":{"line":1030,"column":1}},"children":[{"type":"strong","position":{"start":{"line":1030,"column":1},"end":{"line":1030,"column":1}},"children":[{"type":"text","value":"Statistical Analysis","position":{"start":{"line":1030,"column":1},"end":{"line":1030,"column":1}},"key":"TOe5EfI7U7"}],"key":"gm9QTbMaam"},{"type":"text","value":": IMF and spatial distribution validation","position":{"start":{"line":1030,"column":1},"end":{"line":1030,"column":1}},"key":"QGQJbyHIPW"}],"key":"x449OI08Bg"},{"type":"listItem","spread":true,"position":{"start":{"line":1031,"column":1},"end":{"line":1032,"column":1}},"children":[{"type":"strong","position":{"start":{"line":1031,"column":1},"end":{"line":1031,"column":1}},"children":[{"type":"text","value":"Cluster Evolution","position":{"start":{"line":1031,"column":1},"end":{"line":1031,"column":1}},"key":"Alqdy0vtei"}],"key":"wwGsqxPcBz"},{"type":"text","value":": Understanding of mass segregation and stellar escape","position":{"start":{"line":1031,"column":1},"end":{"line":1031,"column":1}},"key":"F18eIDOgmL"}],"key":"o8e6pF8QbL"}],"key":"HV23tb4tjC"},{"type":"heading","depth":4,"position":{"start":{"line":1033,"column":1},"end":{"line":1033,"column":1}},"children":[{"type":"text","value":"Code Quality and Performance (15%)","position":{"start":{"line":1033,"column":1},"end":{"line":1033,"column":1}},"key":"hZ3kYIDUId"}],"identifier":"code-quality-and-performance-15","label":"Code Quality and Performance (15%)","html_id":"code-quality-and-performance-15","implicit":true,"key":"flmfTfLZvx"},{"type":"list","ordered":false,"spread":false,"position":{"start":{"line":1034,"column":1},"end":{"line":1038,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":1034,"column":1},"end":{"line":1034,"column":1}},"children":[{"type":"strong","position":{"start":{"line":1034,"column":1},"end":{"line":1034,"column":1}},"children":[{"type":"text","value":"Documentation","position":{"start":{"line":1034,"column":1},"end":{"line":1034,"column":1}},"key":"f95EETPGdB"}],"key":"FteYBBLfrG"},{"type":"text","value":": Clear docstrings and code organization","position":{"start":{"line":1034,"column":1},"end":{"line":1034,"column":1}},"key":"ZQ6luh3FAp"}],"key":"LsHbhLTsV9"},{"type":"listItem","spread":true,"position":{"start":{"line":1035,"column":1},"end":{"line":1035,"column":1}},"children":[{"type":"strong","position":{"start":{"line":1035,"column":1},"end":{"line":1035,"column":1}},"children":[{"type":"text","value":"Testing","position":{"start":{"line":1035,"column":1},"end":{"line":1035,"column":1}},"key":"iFv32k4X91"}],"key":"OjZec3RdMI"},{"type":"text","value":": Validation against analytical solutions","position":{"start":{"line":1035,"column":1},"end":{"line":1035,"column":1}},"key":"zr6rEPi5FI"}],"key":"NBuo4ZCyYh"},{"type":"listItem","spread":true,"position":{"start":{"line":1036,"column":1},"end":{"line":1036,"column":1}},"children":[{"type":"strong","position":{"start":{"line":1036,"column":1},"end":{"line":1036,"column":1}},"children":[{"type":"text","value":"Optimization","position":{"start":{"line":1036,"column":1},"end":{"line":1036,"column":1}},"key":"opBbcHsuLF"}],"key":"Irrm51GtIx"},{"type":"text","value":": Efficient use of NumPy vectorization","position":{"start":{"line":1036,"column":1},"end":{"line":1036,"column":1}},"key":"gIM8UA9DMh"}],"key":"xhMoZN5oLX"},{"type":"listItem","spread":true,"position":{"start":{"line":1037,"column":1},"end":{"line":1038,"column":1}},"children":[{"type":"strong","position":{"start":{"line":1037,"column":1},"end":{"line":1037,"column":1}},"children":[{"type":"text","value":"Reproducibility","position":{"start":{"line":1037,"column":1},"end":{"line":1037,"column":1}},"key":"uRxVFeMUAO"}],"key":"f4OLTIF7UH"},{"type":"text","value":": Proper random seed handling","position":{"start":{"line":1037,"column":1},"end":{"line":1037,"column":1}},"key":"ARJxC0Gnko"}],"key":"rOFtco9byo"}],"key":"UGKGj1a8gA"},{"type":"heading","depth":3,"position":{"start":{"line":1039,"column":1},"end":{"line":1039,"column":1}},"children":[{"type":"text","value":"Connection to Project 3","position":{"start":{"line":1039,"column":1},"end":{"line":1039,"column":1}},"key":"RAyL4aCxZ6"}],"identifier":"connection-to-project-3","label":"Connection to Project 3","html_id":"connection-to-project-3","implicit":true,"key":"OMvqhM2mzg"},{"type":"paragraph","position":{"start":{"line":1041,"column":1},"end":{"line":1041,"column":1}},"children":[{"type":"text","value":"The stellar cluster snapshots generated in this project become the radiation sources for Project 3:","position":{"start":{"line":1041,"column":1},"end":{"line":1041,"column":1}},"key":"TwPF9pkjES"}],"key":"hqYvzpbp7T"},{"type":"list","ordered":false,"spread":false,"position":{"start":{"line":1042,"column":1},"end":{"line":1046,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":1042,"column":1},"end":{"line":1042,"column":1}},"children":[{"type":"strong","position":{"start":{"line":1042,"column":1},"end":{"line":1042,"column":1}},"children":[{"type":"text","value":"Stellar positions","position":{"start":{"line":1042,"column":1},"end":{"line":1042,"column":1}},"key":"KcJIKIDylE"}],"key":"neeTDnVtLa"},{"type":"text","value":": Spatial distribution for radiation field calculations","position":{"start":{"line":1042,"column":1},"end":{"line":1042,"column":1}},"key":"MQLXNuHZlI"}],"key":"djLAD2MNib"},{"type":"listItem","spread":true,"position":{"start":{"line":1043,"column":1},"end":{"line":1043,"column":1}},"children":[{"type":"strong","position":{"start":{"line":1043,"column":1},"end":{"line":1043,"column":1}},"children":[{"type":"text","value":"Stellar masses and luminosities","position":{"start":{"line":1043,"column":1},"end":{"line":1043,"column":1}},"key":"EaS3t4bfK5"}],"key":"Gje1mGhslL"},{"type":"text","value":": Heating source strengths","position":{"start":{"line":1043,"column":1},"end":{"line":1043,"column":1}},"key":"YSSqIn8mz8"}],"key":"J9VGeti4y1"},{"type":"listItem","spread":true,"position":{"start":{"line":1044,"column":1},"end":{"line":1044,"column":1}},"children":[{"type":"strong","position":{"start":{"line":1044,"column":1},"end":{"line":1044,"column":1}},"children":[{"type":"text","value":"Cluster evolution","position":{"start":{"line":1044,"column":1},"end":{"line":1044,"column":1}},"key":"WBSa6MyaSh"}],"key":"s2715vEn9C"},{"type":"text","value":": How radiation field changes with time","position":{"start":{"line":1044,"column":1},"end":{"line":1044,"column":1}},"key":"CTh2l7oZKN"}],"key":"M5oNVbkjX1"},{"type":"listItem","spread":true,"position":{"start":{"line":1045,"column":1},"end":{"line":1046,"column":1}},"children":[{"type":"strong","position":{"start":{"line":1045,"column":1},"end":{"line":1045,"column":1}},"children":[{"type":"text","value":"Realistic populations","position":{"start":{"line":1045,"column":1},"end":{"line":1045,"column":1}},"key":"ubSz3NxChe"}],"key":"JY2bgxCsuA"},{"type":"text","value":": IMF-sampled masses give proper luminosity functions","position":{"start":{"line":1045,"column":1},"end":{"line":1045,"column":1}},"key":"QXPiPjNWik"}],"key":"cYyQKDWPR4"}],"key":"nL7HLRXk8n"},{"type":"heading","depth":3,"position":{"start":{"line":1047,"column":1},"end":{"line":1047,"column":1}},"children":[{"type":"text","value":"Deliverables","position":{"start":{"line":1047,"column":1},"end":{"line":1047,"column":1}},"key":"XcjIkeS5qo"}],"identifier":"deliverables","label":"Deliverables","html_id":"deliverables","implicit":true,"key":"zr1FYAd5Pf"},{"type":"heading","depth":4,"position":{"start":{"line":1049,"column":1},"end":{"line":1049,"column":1}},"children":[{"type":"text","value":"Final Submission","position":{"start":{"line":1049,"column":1},"end":{"line":1049,"column":1}},"key":"N33KqaCjha"}],"identifier":"final-submission","label":"Final Submission","html_id":"final-submission","implicit":true,"key":"bYuwCgJZbQ"},{"type":"list","ordered":true,"start":1,"spread":false,"position":{"start":{"line":1050,"column":1},"end":{"line":1064,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":1050,"column":1},"end":{"line":1055,"column":1}},"children":[{"type":"paragraph","position":{"start":{"line":1050,"column":1},"end":{"line":1050,"column":1}},"children":[{"type":"strong","position":{"start":{"line":1050,"column":1},"end":{"line":1050,"column":1}},"children":[{"type":"text","value":"N-Body Simulation Library","position":{"start":{"line":1050,"column":1},"end":{"line":1050,"column":1}},"key":"kU6Hv0urUt"}],"key":"wN2AUbJzq3"},{"type":"text","value":":","position":{"start":{"line":1050,"column":1},"end":{"line":1050,"column":1}},"key":"zLsl2vL2yO"}],"key":"eraAcvbfbg"},{"type":"list","ordered":false,"spread":false,"position":{"start":{"line":1051,"column":1},"end":{"line":1055,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":1051,"column":1},"end":{"line":1051,"column":1}},"children":[{"type":"inlineCode","value":"ode_solvers.py","position":{"start":{"line":1051,"column":1},"end":{"line":1051,"column":1}},"key":"hlWPMnvCFY"},{"type":"text","value":": Integration method implementations","position":{"start":{"line":1051,"column":1},"end":{"line":1051,"column":1}},"key":"hwhJkOvKi2"}],"key":"C1G5s94I8Z"},{"type":"listItem","spread":true,"position":{"start":{"line":1052,"column":1},"end":{"line":1052,"column":1}},"children":[{"type":"inlineCode","value":"stellar_sampling.py","position":{"start":{"line":1052,"column":1},"end":{"line":1052,"column":1}},"key":"Atf0N7oVgj"},{"type":"text","value":": IMF and Plummer sphere classes","position":{"start":{"line":1052,"column":1},"end":{"line":1052,"column":1}},"key":"DXEiMfn9tC"}],"key":"VyLjhRVBHw"},{"type":"listItem","spread":true,"position":{"start":{"line":1053,"column":1},"end":{"line":1053,"column":1}},"children":[{"type":"inlineCode","value":"nbody_simulator.py","position":{"start":{"line":1053,"column":1},"end":{"line":1053,"column":1}},"key":"iqFmL0pa9H"},{"type":"text","value":": Complete adaptive N-body framework","position":{"start":{"line":1053,"column":1},"end":{"line":1053,"column":1}},"key":"NOBRqdHN27"}],"key":"pzkImAUKxw"},{"type":"listItem","spread":true,"position":{"start":{"line":1054,"column":1},"end":{"line":1055,"column":1}},"children":[{"type":"inlineCode","value":"cluster_analysis.py","position":{"start":{"line":1054,"column":1},"end":{"line":1054,"column":1}},"key":"MM9P3Padgy"},{"type":"text","value":": Evolution analysis tools","position":{"start":{"line":1054,"column":1},"end":{"line":1054,"column":1}},"key":"UjwQ0eQtwh"}],"key":"p9j0xnpCSL"}],"key":"Y5XkpPm9hA"}],"key":"MB4JOtDIkq"},{"type":"listItem","spread":true,"position":{"start":{"line":1056,"column":1},"end":{"line":1060,"column":1}},"children":[{"type":"paragraph","position":{"start":{"line":1056,"column":1},"end":{"line":1056,"column":1}},"children":[{"type":"strong","position":{"start":{"line":1056,"column":1},"end":{"line":1056,"column":1}},"children":[{"type":"text","value":"Validation Notebooks","position":{"start":{"line":1056,"column":1},"end":{"line":1056,"column":1}},"key":"HggwO87unN"}],"key":"izlVAkx5zD"},{"type":"text","value":":","position":{"start":{"line":1056,"column":1},"end":{"line":1056,"column":1}},"key":"eOIkqyEAYI"}],"key":"l6mX5uA4vg"},{"type":"list","ordered":false,"spread":false,"position":{"start":{"line":1057,"column":1},"end":{"line":1060,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":1057,"column":1},"end":{"line":1057,"column":1}},"children":[{"type":"inlineCode","value":"orbital_mechanics_validation.ipynb","position":{"start":{"line":1057,"column":1},"end":{"line":1057,"column":1}},"key":"oHYEgM4QQC"},{"type":"text","value":": Two-body problem tests","position":{"start":{"line":1057,"column":1},"end":{"line":1057,"column":1}},"key":"xDyPl2xFQa"}],"key":"yuD6Bmq1Ni"},{"type":"listItem","spread":true,"position":{"start":{"line":1058,"column":1},"end":{"line":1058,"column":1}},"children":[{"type":"inlineCode","value":"sampling_validation.ipynb","position":{"start":{"line":1058,"column":1},"end":{"line":1058,"column":1}},"key":"bVNNQ8Mk0T"},{"type":"text","value":": IMF and spatial distribution verification","position":{"start":{"line":1058,"column":1},"end":{"line":1058,"column":1}},"key":"PgMUNvK8Jg"}],"key":"egC5ngUrpf"},{"type":"listItem","spread":true,"position":{"start":{"line":1059,"column":1},"end":{"line":1060,"column":1}},"children":[{"type":"inlineCode","value":"cluster_evolution_analysis.ipynb","position":{"start":{"line":1059,"column":1},"end":{"line":1059,"column":1}},"key":"MNf16UEWOh"},{"type":"text","value":": Mass segregation and dynamics","position":{"start":{"line":1059,"column":1},"end":{"line":1059,"column":1}},"key":"OHj5emTirM"}],"key":"wf6JaJ7GHS"}],"key":"TPrIeQkXeo"}],"key":"uXMwxmPgys"},{"type":"listItem","spread":true,"position":{"start":{"line":1061,"column":1},"end":{"line":1064,"column":1}},"children":[{"type":"paragraph","position":{"start":{"line":1061,"column":1},"end":{"line":1061,"column":1}},"children":[{"type":"strong","position":{"start":{"line":1061,"column":1},"end":{"line":1061,"column":1}},"children":[{"type":"text","value":"Project 3 Interface","position":{"start":{"line":1061,"column":1},"end":{"line":1061,"column":1}},"key":"dXc1QvAuDR"}],"key":"hMmhPdnx93"},{"type":"text","value":":","position":{"start":{"line":1061,"column":1},"end":{"line":1061,"column":1}},"key":"bResHkT1qV"}],"key":"VEUUZXvG1y"},{"type":"list","ordered":false,"spread":false,"position":{"start":{"line":1062,"column":1},"end":{"line":1064,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":1062,"column":1},"end":{"line":1062,"column":1}},"children":[{"type":"inlineCode","value":"cluster_snapshots.pkl","position":{"start":{"line":1062,"column":1},"end":{"line":1062,"column":1}},"key":"ptQzcPaeHI"},{"type":"text","value":": Saved stellar cluster evolution data","position":{"start":{"line":1062,"column":1},"end":{"line":1062,"column":1}},"key":"P3Y5Xg4DRM"}],"key":"zC9zZ54Bj6"},{"type":"listItem","spread":true,"position":{"start":{"line":1063,"column":1},"end":{"line":1064,"column":1}},"children":[{"type":"inlineCode","value":"snapshot_format.md","position":{"start":{"line":1063,"column":1},"end":{"line":1063,"column":1}},"key":"aAZdBAP1XU"},{"type":"text","value":": Documentation of data structure","position":{"start":{"line":1063,"column":1},"end":{"line":1063,"column":1}},"key":"aB2pkhDIlr"}],"key":"iNspQUzqYJ"}],"key":"g3Fv5O0VDx"}],"key":"jhfTLJy682"}],"key":"Y9xutA8Ojd"},{"type":"paragraph","position":{"start":{"line":1065,"column":1},"end":{"line":1065,"column":1}},"children":[{"type":"text","value":"This project establishes the realistic stellar systems needed for sophisticated radiation calculations while teaching essential computational physics skills: numerical integration, statistical sampling, vectorization, and adaptive methods.","position":{"start":{"line":1065,"column":1},"end":{"line":1065,"column":1}},"key":"FpUKLAqW9l"}],"key":"OucTu20jEx"}],"key":"m5SJGtDTeR"}],"key":"itTKfy2iGg"},"references":{"cite":{"order":[],"data":{}}}}